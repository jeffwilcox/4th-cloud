{
  "name": "streamline",
  "description": "Asynchronous Javascript for dummies",
  "version": "0.2.4",
  "engines": {
    "node": ">=0.4.0"
  },
  "dependencies": {},
  "author": {
    "name": "Bruno Jouhier"
  },
  "directories": {
    "lib": "./lib",
    "bin": "./bin"
  },
  "main": "lib/index.js",
  "bin": {
    "coffee-streamline": "bin\\coffee-streamline",
    "coffee-streamline.cmd": "bin\\coffee-streamline.cmd",
    "node-streamline": "bin\\node-streamline",
    "node-streamline.cmd": "bin\\node-streamline.cmd"
  },
  "contributors": [
    {
      "name": "Bruno Jouhier",
      "email": "bruno.jouhier@sage.com"
    },
    {
      "name": "Preston Guillory",
      "email": "pguillory@gmail.com"
    },
    {
      "name": "Will Conant",
      "email": "will.conant@gmail.com"
    },
    {
      "name": "Aseem Kishore",
      "email": "aseem.kishore@gmail.com"
    },
    {
      "name": "Daniel Ennis",
      "email": "aikar@aikar.co"
    },
    {
      "name": "Marcel Laverdet",
      "email": "marcel@laverdet.com",
      "url": "https://github.com/laverdet/"
    },
    {
      "name": "Evan Worley"
    }
  ],
  "readme": "## streamline.js\n\n`streamline.js` is a small tool to simplify asynchronous Javascript programming.\n\nInstead of writing hairy code like:\n\n```javascript\nfunction lineCount(path, callback) {\n  fs.readFile(path, \"utf8\", function(err, data) {\n    if (err) { callback(err); return; }\n    callback(null, data.split('\\n').length);\n  });\n}\n```\nStreamline.js lets you write:\n\n```javascript\nfunction lineCount(path, _) {\n  return fs.readFile(path, \"utf8\", _).split('\\n').length;\n}\n```\nYou just have to follow a simple rule:\n\n> Replace all callbacks by an underscore and write your code as if all functions were synchronous.\n\nStreamline will transform the code and generate the callbacks for you!\n\nAnd streamline is not limited to a subset of Javascript. \nYou can use all the flow control features of Javascript in your asynchronous code: conditionals, \nloops, `try/catch/finally` blocks, anonymous functions, `this`, etc. \n\nStreamline also provides _futures_, and comes with a small optional library of helper functions (see Goodies section below).\n\n# Generation options\n\nStreamline gives you the choice between generating regular callback-based asynchronous code, \nor generating code that takes advantage of the [fibers library](https://github.com/laverdet/node-fibers).\n\nThe _callback_ option produces code that does not have any special runtime dependencies. You may even use it \nto generate asynchronous code for the browser.\n\nThe _fibers_ option produces simpler code but requires that you install \nthe fibers library (easy: `npm install fibers`). \nThis option gives superior development experience: line numbers are always preserved in the transformed code; \nyou can step with the debugger through asynchronous calls without having to go through complex callbacks, etc.\nIt may also generate more efficient code (to be confirmed by benchmarks).\n\nThe _fibers_ option can be activated by passing `--fibers` to the `node-streamline` command or by \nsetting the `fibers` option when registering streamline \n(see the `register(options)` function in `streamline/lib/compiler/register` or the `streamline/module` API).\n \n# Interoperability with standard node.js code\n\nYou can call standard node functions from streamline code. For example the `fs.readFile` function:\n\n```javascript\nfunction lineCount(path, _) {\n  return fs.readFile(path, \"utf8\", _).split('\\n').length;\n}\n```\nYou can also call streamline functions as if they were standard node functions. For example:\n\n```javascript\nlineCount(\"README.md\", function(err, result) {\n  if (err) return console.error(\"ERROR: \" + err.message);\n  console.log(\"README has \" + result + \" lines.\");\n});\n```\nAnd you can mix streamline functions, classical callback based code and synchrononous functions in the same file. \nStreamline will only transform the functions that have the special `_` parameter. \n\nNote: this works with both transformation options. \nEven if you use the _fibers_ option, you can seamlessly call standard callback based node APIs \nand the asynchronous functions that you create with streamline have the standard node callback signature.\n\n# On-line demo\n\nYou can test `streamline.js` directly with the [on-line demo](http://sage.github.com/streamlinejs/examples/streamlineMe/streamlineMe.html)\n\n# Installation\n\nThe easiest way to install `streamline.js` is with NPM:\n\n```sh\nnpm install streamline -g\n```\n\nThe `-g` option installs it _globally_.\nYou can also install it _locally_, without `-g` but then the `node-streamline` and `coffee-streamline` \ncommands will not be in your default PATH.\n\nNote: If you encounter a permission error when installing on UNIX systems, you should retry with `sudo`. \n\nThe global installation option makes `node-streamline` globally accessible but it does not expose the Javascript support\nmodules (`runtime.js`, `flows.js`, etc.) globally. \nIf you need these modules anywhere in your development tree, \nfor example because you use streamline in shell scripts (see below), \nyou should `npm link` streamline to the root of your development tree:\n\n```sh\ncd $myworkdir\nnpm link streamline\n```\n\nIf you want to use the _fibers_ option, you must also install the fibers library:\n\n```sh\nnpm install fibers [-g]\n```\n\n# Creating and running streamline modules\n\nThe easiest way to write streamline code is to put the following line at the top of your module:\n\n``` javascript\nif (!require('streamline/module')(module)) return;\n```\n\nThen you can use the `_` marker anywhere in your module:\n\n```javascript\nfunction lineCount(path, _) {\n  return fs.readFile(path, \"utf8\", _).split('\\n').length;\n}\n```\n\nYou can run your module with `node-streamline`:\n\n```sh\nnode-streamline myModule\n```\n\nThe code will be automatically transformed and the transformed files will be cached under `~/.streamline`.\n\nYou can also run your module with `node`:\n\n```sh\nnode myModule\n```\n\nIf you run with `node`, streamline will create (and delete) a temporary copy of your source file.\nSo you need r/w access to the module's directory. \nNote that only the main module will be copied, the streamline modules that are _required_ by the main module \nwon't be copied so you don't need r/w access to all directories.\n\n# Coffeescript\n\nCoffeescript is no different. You just need the following line at the top of your module:\n\n```coffeescript\nif not require('streamline/module')(module)\n\treturn\n```\n\nAnd then you can run your module with:\n\n```sh\ncoffee-streamline myModule\n```\n\nor just, if you have r/w access to the module's directory (see `node` above):\n\n```sh\ncoffee myModule\n```\n\n# Shell scripts\n\nYou can also use streamline to write shell scripts that call asynchronous node APIs. \nYou just need the following line at the top of your script:\n\n```sh\n#!/usr/bin/env node-streamline\n```\n\nFor example:\n\n```sh\n#!/usr/bin/env node-streamline\nconsole.log(\"waiting 1 second\");\nsetTimeout(_, 1000);\nconsole.log(\"done!\");\n```\n\nNote: you must install streamline with the `-g` option and you must `npm link` it at the top of your\ndevelopment tree to make this work smoothly (see installation section above).\n  \n# Compilation setup (old style)\n\nYou can also set up your modules to have the streamline source and the transformed Javascript side by side in \nthe same directory. To do this, you must append an underscore to your module's base name: `myModule_.js`.\n\nThis was the original setup. It is nice if you want to see the transformed code but it pollutes the directories \nwith extra files and it becomes messy when you start testing with both callback and fibers mode. \nThe callback output is called `myModule.js` and the fibers' output is called `myModule--fibers.js`.\n\nThe [Compilers wiki page](https://github.com/Sage/streamlinejs/wiki/Compilers) gives details on this mode.\n\n# Browser-side use\n\nThe [streamline compiler](https://github.com/Sage/streamlinejs/wiki/Compilers) generates vanilla Javascript code that may be run browser-side too.\n\nYou can also transform the code in the browser with the `transform` API. See `examples/streamlineMe` for an example.\n\nThe `lib/require` directory contains a small infrastructure to load streamline and regular JS modules from the browser. \nIt applies the streamline transformation server side and caches the transformed files.\nIt also optimizes roundtrips between client and server: \nthe _required_ module and all its dependencies are transferred in one message.\nAlso, dependencies that have already been transferred to the browser are not re-transferred \nwhen you require additional modules.\n\nNote: the `lib/require` infrastructure does not handle all the subtleties of node's require logic but it handles enough to\nsupport our applications (and it does it very efficiently).\nIt is provided _as is_ and contributions to improve it are welcome.\n\n# Examples\n\nThe `examples/diskUsage` directory contains a simple example that traverses directories to compute disk usage.\nYou can run it as follows:\n\n```sh\nnode-streamline diskUsage\nnode diskUsage # requires r/w access to the examples directory\n```\n\nThe `diskUsage2.js` example is a faster variant that parallelizes I/O operations with futures. \nYou'll also find CoffeeScript versions of these examples.\n\n# Goodies\n\nThe functions generated by streamline return a _future_ if you call them without a callback. \nThis gives you an easy way to run several asynchronous operations in parallel and resynchronize later. \nSee the [futures](https://github.com/Sage/streamlinejs/wiki/Futures) wiki page for details.\n\nThe following subdirectories contain various modules that have been written with streamline.js:\n\n* `lib/util`: utilities for array manipulation, semaphores, etc.\n* `lib/streams`: pull-mode API for node.js streams.\n* `lib/require`: infrastructure to support client-side require.\n* `lib/tools`: small tools (doc generator for API.md file).\n\n## Resources\n\nThe API is documented [here](https://github.com/Sage/streamlinejs/blob/master/API.md).  \nThe [wiki](https://github.com/Sage/streamlinejs/wiki) give more information on advanced topics.\n\nFor support and discussion, please join the [streamline.js Google Group](http://groups.google.com/group/streamlinejs).\n\n## Credits\n\nSee the [AUTHORS](https://github.com/Sage/streamlinejs/blob/master/AUTHORS) file.\n\nSpecial thanks to Marcel Laverdet who contributed the _fibers_ implementation.\n\n## License\n\nThis work is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).\n",
  "_id": "streamline@0.2.4",
  "dist": {
    "shasum": "79486724eed7801259e9c9e41970bbaf770ffb34"
  },
  "_from": "streamline@0.2.4"
}
